-- In-Game Inventory â†’ Discord Webhook (No Accessories)
-- Works in Studio (HttpService enabled) and most executors (http_request/syn.request)

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

-- ========= CONFIG =========
local WEBHOOK_URL = "https://discord.com/api/webhooks/1410488907358933063/unmfmZmJVyaxMnj7Pbw-_U5q4J7zlLvC4xwxwgRGvHrWKH0yVRHF8-em1KJJ6DbSkiqU" -- <- your webhook
-- =========================

local player = Players.LocalPlayer

-- Utility: collect Tool names from a container (Backpack, StarterGear, Character)
local function collectTools(container)
    local items = {}
    if not container then return items end
    for _, obj in ipairs(container:GetChildren()) do
        if obj:IsA("Tool") then
            table.insert(items, obj.Name)
        end
    end
    table.sort(items, function(a,b) return a:lower() < b:lower() end)
    return items
end

-- Snapshot current inventory
local backpackTools   = collectTools(player and player:FindFirstChild("Backpack"))
local starterGear     = collectTools(player and player:FindFirstChild("StarterGear"))
local equippedTools   = collectTools(player and player.Character)

-- Build readable sections
local function section(label, list)
    return "**" .. label .. ":** " .. (#list > 0 and table.concat(list, ", ") or "None")
end

local description = table.concat({
    "Username: " .. player.Name,
    "UserId: " .. player.UserId,
    "",
    section("Backpack", backpackTools),
    section("StarterGear", starterGear),
    section("Equipped Tools", equippedTools),
}, "\n")

local payload = {
    content = "**In-Game Inventory Log**",
    embeds = {{
        title = "Inventory Snapshot",
        description = description,
        color = 3447003
    }}
}

local jsonBody = HttpService:JSONEncode(payload)

-- Sender that tries HttpService first, then common executor request funcs
local function sendWebhook(json)
    -- Try HttpService (Studio / your game with HTTP enabled)
    local ok = pcall(function()
        HttpService:PostAsync(WEBHOOK_URL, json, Enum.HttpContentType.ApplicationJson)
    end)
    if ok then return true end

    -- Fallback for executors
    local req = rawget(getfenv(), "http_request")
              or rawget(getfenv(), "request")
              or (syn and syn.request)
              or (fluxus and fluxus.request)
              or (krnl and krnl.request)

    if req then
        local res = req({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = json
        })
        return true
    else
        warn("[Inventory Webhook] No HTTP available. Enable HttpService or use an executor with http_request.")
        return false
    end
end

sendWebhook(jsonBody)
